---
title: ' Wrangling Census data with tidyverse tools'
tutorial:
  id: 03-wrangling-census-data
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: Tutorial for Chapter 3
---

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)
library(tidycensus)
library(tidyverse)


knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 
```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

## Introduction
Lets learn how to use tidyverse tools to gain insight on US Census data. We (mostly) follow the approach of [*Analyzing US Census Data: Methods, Maps, and Models in R*](https://walker-data.com/census-r/index.html) by Kyle Walker.
### 

<!-- Two to four sentence about the main topics covered in this tutorial. Why are we here? What will students get out of giving you 90 minutes of their lives? How does this tutorial connect to other tutorials? -->

## First section (use sentence case)
### Exercise 1

Start your code by loading in the **tidyverse** and **tidycensus** package

```{r first-section-use-se-1, exercise = TRUE}

```

```{r first-section-use-se-1-hint-1, eval = FALSE}
library(...)
library(...)
```

```{r include = FALSE}
library(tidyverse)
library(tidycensus)
```

The tidyverse is a collection of R packages that are designed to work together in common data wrangling, analysis, and visualization projects. The **tidyverse** specifically a package itself, but rather loads several core packages within the tidyverse.



### Exercise 2

For a first example, let’s request data on median age from the 2016-2020 ACS with `get_acs()` for all counties in the United States. Set median_age to `get_acs()` with geography = "county", variables = B01002_001, and the year = 2020.



```{r first-section-use-se-2, exercise = TRUE}

```

```{r first-section-use-se-2-hint-1, eval = FALSE}
median_age <- get_acs(
  geography = "...",
  variables = "B01002_001",
  year = ...
)
```

```{r include = FALSE}
median_age <- get_acs(
  geography = "county",
  variables = "B01002_001",
  year = 2020
)
```

The default method for printing data used by the **tibble** package shows the first 10 rows of the dataset, which in this case prints counties in Alabama. On the right hand side of the tibble you can see both moe and estimate, both of which we will talk about later in the chapter. 



### Exercise 3

`arrange()` sorts a dataset by values in one or more columns and returns the sorted result. To view the dataset in ascending order of a given column, supply the data object(median_age) and a column name(let's do estimate) to the arrange() function.

```{r first-section-use-se-3, exercise = TRUE}

```

```{r first-section-use-se-3-hint-1, eval = FALSE}
arrange(..., estimate)
```

```{r include = FALSE}
arrange(median_age, estimate)
```

Per the 2016-2020 ACS, the youngest county is De Baca County, New Mexico. Two of the five youngest “counties” in the United States are independent cities in Virginia, which are treated as county-equivalents. 


### Exercise 4

New lets try to find the oldest counties in the US by median age. Use the `arrange()` function for the same dataset but instead use `desc(estimate)`.

```{r first-section-use-se-4, exercise = TRUE}

```

```{r first-section-use-se-4-hint-1, eval = FALSE}
arrange(median_age, desc(...))
```

```{r include = FALSE}
arrange(median_age, desc(estimate))
```

Notice how Sumter county is the oldest county in our tibble. The **dplyr** package in the tidyverse has a variety of functions including `arrange()`.



### 

Now try to answer the question: How many counties in the US have a median age of 50 or older?

### Exercise 5

Lets try filtering our median_age data set. Use `arrange()`, with median_age and our estimate >= 50. 


```{r first-section-use-se-5, exercise = TRUE}

```

```{r first-section-use-se-5-hint-1, eval = FALSE}
filter(median_age, ... >= 50)
```

```{r include = FALSE}
filter(median_age, estimate >= 50)
```

The `filter()` function queries a data set for rows where a given condition evaluates to TRUE, and retains those rows only. In this case, the data set is filtering our median_age data set for counties that have a median age of 50 or older. 

### 

What if we want to separate the columns into county and state?

### Exercise 6

Notice above how our column for location is called NAME. To make it less confusing, use the `separate()` function with your dataset median_age, the column NAME, into = c("county","state") , and sep = ", "  



```{r first-section-use-se-6, exercise = TRUE}

```

```{r first-section-use-se-6-hint-1, eval = FALSE}
separate(
  median_age,
  NAME,
  into = c(..., ...),
  sep = ", "
)
```

```{r include = FALSE}
separate(
  median_age,
  NAME,
  into = c("county", "state"),
  sep = ", "
)
```

The `seperate()` function of the **dyplr** package allows us to separate a column. 
### 

Since some data have too much information to count, we can normalize this data by dividing the total population into different variables.

### Exercise 7

Lets do this by setting race_vars to White = "B03002_003", Black = "B03002_004",
Native = "B03002_005", Asian = "B03002_006", HIPI = "B03002_007", and Hispanic = "B03002_012". 
  
```{r first-section-use-se-7, exercise = TRUE}

```

```{r first-section-use-se-7-hint-1, eval = FALSE}
race_vars <- c(
  White = "B03002_003",
  Black = "...",
  Native = "B03002_005",
  Asian = "...",
  HIPI = "B03002_007",
  Hispanic = "..."
)
```

```{r include = FALSE}
race_vars <- c(
  White = "B03002_003",
  Black = "B03002_004",
  Native = "B03002_005",
  Asian = "B03002_006",
  HIPI = "B03002_007",
  Hispanic = "B03002_012"
)
```

This separates our dataset race_vars to different variables. 

### Exercise 8

Let's try accessing the Decennial Census database. In order to do this, we'll use the `get_decennial()` function with the `geography`, `variables`, and `year` arguments.

### 

Let's try to find the total American population by state. First of all, we need to access the variable containing these populations, which is `P001001`.

### 

Run `get_decennial()` below setting `geography` to  `"state"`, `variables` to `"P001001"`, and `year` to `2010`.

```{r first-section-use-ce-8, exercise = TRUE}

```

```{r first-section-use-ce-8-hint-1, eval = FALSE}
get_decennial(... = "...", 
              variables = "..."
              ... = 2010)
```



### 

This should return a tibble with 52 rows and 4 columns.


### 

The `geography` argument determines the scope of the data (such as `us` for the entire country and `county` for counties), the `variables` argument defines which variables you want to use, and the `year` argument defines the year that our data comes from.

### Exercise 9

Copy and paste your code from above and change the `year` argument, and set it to `2020`. Change the `variables` argument to `"P1_001N"`, because the `"P001001"` was renamed starting in 2020.

```{r first-section-use-ce-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r first-section-use-ce-9-hint-1, eval = FALSE}
get_decennial(... = "...", 
              variables = "...",
              year = ...)
```

### 

By changing the `year` argument, we can specify when we want our data to be from. 

### Exercise 10

Along with the arguments we have already learned, there is also the `sumfile` argument, or "summary file". 

### 

Run the `get_decennial()` function below setting `geography` to `"state"`, `variables` to `"P1_005N"`, `year` to `2020`, and `sumfile` to `"pl"`.

```{r first-section-use-ce-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r first-section-use-ce-10-hint-1, eval = FALSE}
get_decennial(geography = "...",
        variables      = "...",
        year = ...,
        sumfile = "..."
)
```

### 

This retrieves information on the American Indian & Alaska Native population by state from the 2020 decennial Census. The `pl` summary file is one type that is a limited subset of variables from the decennial US Census to be used for legislative redistricting. 

To learn more about the `sumfile`, we again recommend Walker's [book](https://walker-data.com/census-r/an-introduction-to-tidycensus.html#getting-started-with-tidycensus).

### Exercise 11

Just as `get_decennial()` gets information from the Decennial Census, `get_acs()` gets information from the **A**merican **C**ommunity **S**urvey. 

### 

Run the `get_acs()` function setting `geography` to  `"state"`, `variables` to `"B05006_150"` and `year` to `2021`.

```{r first-section-use-ce-11, exercise = TRUE}

```

```{r first-section-use-ce-11-hint-1, eval = FALSE}
get_acs(geography = "...",
        variables      = "...",
        year = ...
)
```

### 

The example above fetches data on the number of residents born in Mexico by state. Notice that the tibble produced has an `estimate` and a `moe` column rather than a `value` column like the Decennial Census data. 

<!-- DK: Awkward. -->

**This is important.**

### Exercise 12

Along with the arguments, we've already learned, there is also a `survey` argument. This argument defaults to 5 year periods if not specified. We can change it to a one-year period rather than a default 5-year period by adding `survey = "acs1"`.

### 

Run `get_acs` below setting `geography` to `"state"`, `variables` to `"B05006_150"`, `survey` = `"acs1"`, and `year` to `2021`.


```{r first-section-use-ce-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r first-section-use-ce-12-hint-1, eval = FALSE}
get_acs(... = "...", 
        variables = "...", 
        survey = "...",
        ... = 2019)
```

### 

The above function yields data on the number of residents born in Mexico by state in the year of just 2021 instead of a 5-year period as earlier. 

### 

Notice that the GEOID column contains the [FIPS code](https://transition.fcc.gov/oet/info/maps/census/fips/fips.txt#:~:text=FIPS%20codes%20are%20numbers%20which,to%20which%20the%20county%20belongs.) of the area the data covers. This code is a standardized way to identify different geographical areas. It gets larger as the area under consideration narrows. The FIPS for Massachusetts is 25. For Middlesex County within Massachusetts, the FIPS is 25017.


### Exercise 13

Rather than using the `variables` argument, you can supply a table name to the `table` parameter in `get_acs()`; this will return data for every variable in that table. 

Run `get_acs()` below setting `geography` to `"state"`, `table` to `"B01001"`, and `year` to `2021`

```{r first-section-use-ce-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r first-section-use-ce-13-hint-1, eval = FALSE}
get_acs(... = "...", 
        table = "...",
        ... = ...)
```

### 

This code got all variables associated with table `B01001`, which covers sex broken down by age, from the 2017-2021 5-year ACS.

## Summary
### 

<!-- Two to four sentences which bring the lessons of the tutorial together for the student. What do they know now that they did not know before? How does this tutorial connect to other tutorials? OK if this is very similar to the Introduction. You made a promise as to what they would learn. You (we hope!) kept that promise.-->

```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
